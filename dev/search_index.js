var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#Observables-and-Coupling","page":"API Reference","title":"Observables and Coupling","text":"","category":"section"},{"location":"api/#Problem-Construction","page":"API Reference","title":"Problem Construction","text":"","category":"section"},{"location":"api/#Solver","page":"API Reference","title":"Solver","text":"","category":"section"},{"location":"api/#Operator-Application","page":"API Reference","title":"Operator Application","text":"","category":"section"},{"location":"api/#Parameter-Sweeps","page":"API Reference","title":"Parameter Sweeps","text":"","category":"section"},{"location":"api/#Rigorous-Verification","page":"API Reference","title":"Rigorous Verification","text":"","category":"section"},{"location":"api/#I/O","page":"API Reference","title":"I/O","text":"","category":"section"},{"location":"api/#Indexing-Utilities","page":"API Reference","title":"Indexing Utilities","text":"","category":"section"},{"location":"api/#SelfConsistentLogisticNoise.LogisticMap","page":"API Reference","title":"SelfConsistentLogisticNoise.LogisticMap","text":"LogisticMap(a)\n\nLogistic map T_a(x) = ax(1-x) on the torus.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.GaussianNoise","page":"API Reference","title":"SelfConsistentLogisticNoise.GaussianNoise","text":"GaussianNoise(œÉ)\n\nPeriodized Gaussian noise kernel on the torus with standard deviation œÉ. Fourier coefficients: œÅÃÇ_œÉ(k) = exp(-2œÄ¬≤œÉ¬≤k¬≤)\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.FourierDisc","page":"API Reference","title":"SelfConsistentLogisticNoise.FourierDisc","text":"FourierDisc(N, M)\n\nFourier discretization parameters.\n\nN: truncation level (modes from -N to N, total 2N+1 coefficients)\nM: FFT oversampling grid size (typically M = os * (2N+1) with os = 8 or 16)\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.SCProblem","page":"API Reference","title":"SelfConsistentLogisticNoise.SCProblem","text":"SCProblem\n\nSelf-consistent problem specification containing all parameters and the precomputed B matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.CosineObservable","page":"API Reference","title":"SelfConsistentLogisticNoise.CosineObservable","text":"CosineObservable()\n\nDefault observable Œ¶(x) = cos(2œÄx). Fourier coefficients: Œ¶ÃÇ‚ÇÅ = Œ¶ÃÇ‚Çã‚ÇÅ = 1/2, others = 0.\n\nFor this observable: m(f) = Re(fÃÇ‚ÇÅ)\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.LinearCoupling","page":"API Reference","title":"SelfConsistentLogisticNoise.LinearCoupling","text":"LinearCoupling(Œ¥, observable)\n\nLinear coupling: G(m) = m, so c(f) = Œ¥ * m(f).\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.TanhCoupling","page":"API Reference","title":"SelfConsistentLogisticNoise.TanhCoupling","text":"TanhCoupling(Œ¥, Œ≤, observable)\n\nSaturating coupling: G(m) = tanh(Œ≤*m), so c(f) = Œ¥ * tanh(Œ≤ * m(f)).\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.build_problem","page":"API Reference","title":"SelfConsistentLogisticNoise.build_problem","text":"build_problem(; a=3.83, œÉ=0.02, N=256, Œ¥=0.0, coupling_type=:linear, Œ≤=1.0, oversample=8, cache=true)\n\nConvenience function to build a complete SCProblem.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.build_B","page":"API Reference","title":"SelfConsistentLogisticNoise.build_B","text":"build_B(map::LogisticMap, disc::FourierDisc; cache=true, cache_dir=\".cache\")\n\nBuild the matrix Ba where:     (Ba){k,‚Ñì} = ‚à´ùïã e^{-2œÄik T_a(y)} e^{2œÄi‚Ñìy} dy\n\nUses FFT trick: for each k, compute Fourier coefficients of gk(y) = e^{-2œÄik Ta(y)} by sampling on a fine grid and taking FFT.\n\nIf cache=true, attempts to load from / save to disk.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.solve_fixed_point","page":"API Reference","title":"SelfConsistentLogisticNoise.solve_fixed_point","text":"solve_fixed_point(prob::SCProblem; kwargs...)\n\nSolve for fixed point f* such that ùíØ(f) = f using damped Picard iteration.\n\nKeyword Arguments\n\nŒ±=0.2: damping parameter (0 < Œ± ‚â§ 1). Smaller values give more stability.\ntol=1e-12: convergence tolerance for relative residual.\nmaxit=5000: maximum number of iterations.\ninit=:uniform: initial condition (:uniform, :bump, :random, or a Vector{ComplexF64})\nverbose=false: print progress information.\nenforce_symmetry=true: enforce conjugate symmetry at each step.\n\nReturns\n\nFixedPointResult containing converged solution and diagnostics.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.FixedPointResult","page":"API Reference","title":"SelfConsistentLogisticNoise.FixedPointResult","text":"FixedPointResult\n\nResult of a fixed-point computation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.apply_Pc","page":"API Reference","title":"SelfConsistentLogisticNoise.apply_Pc","text":"apply_Pc(prob::SCProblem, fhat::Vector{ComplexF64}, c::Float64)\n\nApply the noisy transfer operator with shift c:     (Pc f)ÃÇk = œÅÃÇœÉ(k) * e^{-2œÄikc} * (Ba fÃÇ)_k\n\nwhere œÅÃÇ_œÉ(k) = exp(-2œÄ¬≤œÉ¬≤k¬≤) is the Gaussian kernel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.reconstruct_density","page":"API Reference","title":"SelfConsistentLogisticNoise.reconstruct_density","text":"reconstruct_density(fhat::Vector{ComplexF64}, xgrid::AbstractVector)\n\nReconstruct density f(x) from Fourier coefficients on the given grid.\n\n\n\n\n\nreconstruct_density(fhat::Vector{ComplexF64}; npts=1000)\n\nReconstruct density on a uniform grid with npts points.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.sweep_delta","page":"API Reference","title":"SelfConsistentLogisticNoise.sweep_delta","text":"sweep_delta(prob::SCProblem, Œ¥_range; warm_start=true, kwargs...)\n\nSweep over Œ¥ values, optionally using warm-start continuation.\n\nReturns a DataFrame with columns: Œ¥, m, c, residual, iterations, converged\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.sweep_delta_a","page":"API Reference","title":"SelfConsistentLogisticNoise.sweep_delta_a","text":"sweep_delta_a(; a_range, Œ¥_range, œÉ=0.02, N=256, kwargs...)\n\nSweep over both a and Œ¥ values.\n\nReturns a DataFrame with columns: a, Œ¥, m, c, residual, iterations, converged\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.multistart_solve","page":"API Reference","title":"SelfConsistentLogisticNoise.multistart_solve","text":"multistart_solve(prob::SCProblem; n_starts=5, kwargs...)\n\nRun solver from multiple initial conditions to detect multiple fixed points.\n\nReturns a vector of FixedPointResults, clustered by uniqueness.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.verify_fixed_point","page":"API Reference","title":"SelfConsistentLogisticNoise.verify_fixed_point","text":"verify_fixed_point(prob, fhat; œÑ=0.01, verbose=false)\n\nAttempt to rigorously verify that fhat is close to a true fixed point. Uses BallArithmetic for certified bounds on singular values.\n\nReturns a RigorousResult with verification status and all computed constants.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.RigorousResult","page":"API Reference","title":"SelfConsistentLogisticNoise.RigorousResult","text":"RigorousResult\n\nResult of rigorous verification.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.GaussianConstants","page":"API Reference","title":"SelfConsistentLogisticNoise.GaussianConstants","text":"GaussianConstants\n\nContainer for the Gaussian smoothing constants S{œÑ,œÉ}, S^(1){œÑ,œÉ}, S^(2)_{œÑ,œÉ}.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.compute_gaussian_constants","page":"API Reference","title":"SelfConsistentLogisticNoise.compute_gaussian_constants","text":"compute_gaussian_constants(œÉ, œÑ)\n\nCompute the Gaussian smoothing constants for given œÉ and œÑ. Uses exact computation by checking k near the continuous maximizer.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.compute_jacobian_matrix","page":"API Reference","title":"SelfConsistentLogisticNoise.compute_jacobian_matrix","text":"compute_jacobian_matrix(prob::SCProblem, fhat::Vector{ComplexF64})\n\nCompute the Jacobian DT_N(f) = A(c) + b ‚äó a* at the candidate fÃÇ. Returns the full matrix representation.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.save_result","page":"API Reference","title":"SelfConsistentLogisticNoise.save_result","text":"save_result(filename::String, result::FixedPointResult)\n\nSave a FixedPointResult to a JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.load_result","page":"API Reference","title":"SelfConsistentLogisticNoise.load_result","text":"load_result(filename::String)\n\nLoad a FixedPointResult from a JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.modes","page":"API Reference","title":"SelfConsistentLogisticNoise.modes","text":"modes(N)\n\nReturn the range of Fourier modes: -N:N\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.idx","page":"API Reference","title":"SelfConsistentLogisticNoise.idx","text":"idx(k, N)\n\nConvert Fourier mode k ‚àà {-N,...,N} to 1-based array index. Mode k maps to index k + N + 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.mode","page":"API Reference","title":"SelfConsistentLogisticNoise.mode","text":"mode(i, N)\n\nConvert 1-based array index i to Fourier mode k. Index i maps to mode i - (N+1).\n\n\n\n\n\n","category":"function"},{"location":"theory/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"theory/#The-Self-Consistent-Model","page":"Mathematical Background","title":"The Self-Consistent Model","text":"","category":"section"},{"location":"theory/#State-Space","page":"Mathematical Background","title":"State Space","text":"We work on the torus mathbbT = mathbbRmathbbZ, represented as 01) with wrap-around.","category":"section"},{"location":"theory/#The-Logistic-Map","page":"Mathematical Background","title":"The Logistic Map","text":"T_a(x) = a cdot x(1-x)\n\nWe interpret all phases in mathbbT (mod 1) when combining with noise and shift.","category":"section"},{"location":"theory/#Periodized-Gaussian-Noise","page":"Mathematical Background","title":"Periodized Gaussian Noise","text":"Let barrho_sigma be the periodized Gaussian kernel on mathbbT. Its Fourier coefficients are:\n\nwidehatbarrho_sigma(k) = exp(-2pi^2 sigma^2 k^2)","category":"section"},{"location":"theory/#Noisy-Transfer-Operator-with-Shift","page":"Mathematical Background","title":"Noisy Transfer Operator with Shift","text":"For each shift c in mathbbR:\n\n(P_c f)(x) = int_mathbbT barrho_sigma(x - T_a(y) - c) f(y)  dy","category":"section"},{"location":"theory/#Self-Consistency","page":"Mathematical Background","title":"Self-Consistency","text":"We define:\n\nObservable: m(f) = langle Phi f rangle = int_mathbbT Phi(x) f(x)  dx\nCoupling: c(f) = delta cdot G(m(f))\n\nThe self-consistent operator is:\n\nmathcalT(f) = P_c(f) f\n\nGoal: Find fixed points f^* with mathcalT(f^*) = f^*, int f^* = 1, f^* geq 0.","category":"section"},{"location":"theory/#Fourier-Discretization","page":"Mathematical Background","title":"Fourier Discretization","text":"","category":"section"},{"location":"theory/#Truncated-Fourier-Series","page":"Mathematical Background","title":"Truncated Fourier Series","text":"Densities are represented by truncated Fourier series:\n\nf(x) approx sum_k=-N^N hatf_k e^2pi i k x","category":"section"},{"location":"theory/#Operator-in-Fourier-Coordinates","page":"Mathematical Background","title":"Operator in Fourier Coordinates","text":"Define:\n\n(B_a hatf)_k = int_mathbbT e^-2pi i k T_a(y) f(y)  dy\n\nThen:\n\nwidehat(P_c f)_k = underbracee^-2pi^2 sigma^2 k^2_textGaussian cdot underbracee^-2pi i k c_textshift phase cdot (B_a hatf)_k","category":"section"},{"location":"theory/#Building-B_a-via-FFT","page":"Mathematical Background","title":"Building B_a via FFT","text":"Matrix entries:\n\n(B_a)_kell = int_mathbbT e^-2pi i k T_a(y) e^2pi i ell y  dy\n\nFFT trick: For each k, sample g_k(y) = e^-2pi i k T_a(y) on a fine grid and compute FFT.","category":"section"},{"location":"theory/#Rigorous-Verification-(Newton-Kantorovich)","page":"Mathematical Background","title":"Rigorous Verification (Newton-Kantorovich)","text":"The package implements rigorous computer-assisted proofs based on the Newton-Kantorovich theorem.","category":"section"},{"location":"theory/#Key-Constants","page":"Mathematical Background","title":"Key Constants","text":"For Gaussian smoothing with parameter sigma and analytic strip width tau:\n\nS_tausigma = sup_k in mathbbZ exp(2pitauk - 2pi^2sigma^2 k^2)\n\nS^(1)_0sigma leq frac1sigmasqrte quad S^(2)_0sigma leq frac2sigma^2 e","category":"section"},{"location":"theory/#Kantorovich-Condition","page":"Mathematical Background","title":"Kantorovich Condition","text":"Given a numerical candidate tildef with residual bound Delta, inverse Jacobian bound M, and Lipschitz constant gamma:\n\nIf h = M^2 gamma Delta leq frac12, then there exists a unique true fixed point f^* with:\n\nf^* - tildef_2 leq r = frac1 - sqrt1 - 2hMgamma","category":"section"},{"location":"#SelfConsistentLogisticNoise.jl","page":"Home","title":"SelfConsistentLogisticNoise.jl","text":"A Julia package for computing fixed points of self-consistent noisy transfer operators associated with the logistic family.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This package implements numerical methods for finding fixed points of the self-consistent operator:\n\nmathcalT(f) = P_c(f) f\n\nwhere:\n\nT_a(x) = a cdot x(1-x) is the logistic map\nP_c is the noisy transfer operator with periodized Gaussian noise and shift c\nc(f) = delta cdot G(m(f)) is a self-consistent shift depending on the density f\nm(f) = langle Phi f rangle is an observable (e.g., Phi(x) = cos(2pi x))","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Fourier discretization with FFT-based operator construction\nDamped Picard iteration for fixed-point computation\nWarm-start continuation for parameter sweeps\nRigorous verification via Newton-Kantorovich theorem using BallArithmetic.jl","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using SelfConsistentLogisticNoise\n\n# Build problem: logistic map with a=3.83, noise œÉ=0.02, coupling Œ¥=0.1\nprob = build_problem(a=3.83, œÉ=0.02, N=64, Œ¥=0.1)\n\n# Solve for fixed point\nresult = solve_fixed_point(prob; Œ±=0.3, tol=1e-10, verbose=true)\n\n# Reconstruct and plot density\nx, f = reconstruct_density(result.fhat; npts=500)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"This package is not registered. Install via:\n\nusing Pkg\nPkg.add(url=\"https://github.com/orkolorko/SelfConsistentLogisticNoise.jl\")","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"theory.md\", \"tutorials/fixed_point_tutorial.md\", \"api.md\"]\nDepth = 2","category":"section"}]
}
