var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#Observables-and-Coupling","page":"API Reference","title":"Observables and Coupling","text":"","category":"section"},{"location":"api/#Problem-Construction","page":"API Reference","title":"Problem Construction","text":"","category":"section"},{"location":"api/#Solver","page":"API Reference","title":"Solver","text":"","category":"section"},{"location":"api/#Operator-Application","page":"API Reference","title":"Operator Application","text":"","category":"section"},{"location":"api/#Parameter-Sweeps","page":"API Reference","title":"Parameter Sweeps","text":"","category":"section"},{"location":"api/#Rigorous-Verification","page":"API Reference","title":"Rigorous Verification","text":"","category":"section"},{"location":"api/#I/O","page":"API Reference","title":"I/O","text":"","category":"section"},{"location":"api/#Indexing-Utilities","page":"API Reference","title":"Indexing Utilities","text":"","category":"section"},{"location":"api/#SelfConsistentLogisticNoise.QuadraticMap","page":"API Reference","title":"SelfConsistentLogisticNoise.QuadraticMap","text":"QuadraticMap(a)\n\nQuadratic map T_a(x) = a - (a+1)x^2 on the period-2 torus [-1,1].\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.GaussianNoise","page":"API Reference","title":"SelfConsistentLogisticNoise.GaussianNoise","text":"GaussianNoise(œÉ)\n\nPeriodized Gaussian noise kernel on the period-2 torus with standard deviation œÉ. Fourier coefficients: œÅÃÇ_œÉ(k) = exp(-(œÄ¬≤/2)œÉ¬≤k¬≤)\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.FourierDisc","page":"API Reference","title":"SelfConsistentLogisticNoise.FourierDisc","text":"FourierDisc(N, M)\n\nFourier discretization parameters.\n\nN: truncation level (modes from -N to N, total 2N+1 coefficients)\nM: FFT oversampling grid size (typically M = os * (2N+1) with os = 8 or 16)\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.SCProblem","page":"API Reference","title":"SelfConsistentLogisticNoise.SCProblem","text":"SCProblem\n\nSelf-consistent problem specification containing all parameters and the precomputed B matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.CosineObservable","page":"API Reference","title":"SelfConsistentLogisticNoise.CosineObservable","text":"CosineObservable()\n\nDefault observable Œ¶(x) = cos(œÄx). Fourier coefficients: Œ¶ÃÇ‚ÇÅ = Œ¶ÃÇ‚Çã‚ÇÅ = 1/2, others = 0.\n\nFor this observable: m(f) = Re(fÃÇ‚ÇÅ)\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.LinearCoupling","page":"API Reference","title":"SelfConsistentLogisticNoise.LinearCoupling","text":"LinearCoupling(Œ¥, observable)\n\nLinear coupling: G(m) = m, so c(f) = Œ¥ * m(f).\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.TanhCoupling","page":"API Reference","title":"SelfConsistentLogisticNoise.TanhCoupling","text":"TanhCoupling(Œ¥, Œ≤, observable)\n\nSaturating coupling: G(m) = tanh(Œ≤*m), so c(f) = Œ¥ * tanh(Œ≤ * m(f)).\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.build_problem","page":"API Reference","title":"SelfConsistentLogisticNoise.build_problem","text":"build_problem(; a=0.915, œÉ=0.02, N=256, Œ¥=0.0, coupling_type=:linear,\n              Œ≤=1.0, oversample=8, Œ∑=0.1, œÉ_sm=0.005,\n              taper=true, M_override=nothing, cache=true)\n\nConvenience function to build a complete SCProblem.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.build_B","page":"API Reference","title":"SelfConsistentLogisticNoise.build_B","text":"build_B(map::QuadraticMap, disc::FourierDisc; cache=true, cache_dir=\".cache\",\n        Œ∑=0.1, œÉ_sm=0.005, taper=true)\n\nBuild the matrix Ba where:     (Ba){k,‚Ñì} = (1/2)‚à´{-1}^{1} e^{-iœÄk T_a(y)} e^{iœÄ‚Ñìy} dy\n\nUses FFT trick: for each k, compute Fourier coefficients of gk(y) = e^{-iœÄk Ta(y)}. When taper=true, uses the tapered + smoothed map TÃÉ_a. by sampling on a fine grid and taking FFT.\n\nIf cache=true, attempts to load from / save to disk.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.solve_fixed_point","page":"API Reference","title":"SelfConsistentLogisticNoise.solve_fixed_point","text":"solve_fixed_point(prob::SCProblem; kwargs...)\n\nSolve for fixed point f* such that ùíØ(f) = f using damped Picard iteration.\n\nKeyword Arguments\n\nŒ±=0.2: damping parameter (0 < Œ± ‚â§ 1). Smaller values give more stability.\ntol=1e-12: convergence tolerance for relative residual.\nmaxit=5000: maximum number of iterations.\ninit=:uniform: initial condition (:uniform, :bump, :random, or a Vector{ComplexF64})\nverbose=false: print progress information.\nenforce_symmetry=true: enforce conjugate symmetry at each step.\n\nReturns\n\nFixedPointResult containing converged solution and diagnostics.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.FixedPointResult","page":"API Reference","title":"SelfConsistentLogisticNoise.FixedPointResult","text":"FixedPointResult\n\nResult of a fixed-point computation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.apply_Pc","page":"API Reference","title":"SelfConsistentLogisticNoise.apply_Pc","text":"apply_Pc(prob::SCProblem, fhat::Vector{ComplexF64}, c::Float64)\n\nApply the noisy transfer operator with shift c:     (Pc f)ÃÇk = œÅÃÇœÉ(k) * e^{-iœÄkc} * (Ba fÃÇ)_k\n\nwhere œÅÃÇ_œÉ(k) = exp(-(œÄ¬≤/2)œÉ¬≤k¬≤) is the Gaussian kernel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.reconstruct_density","page":"API Reference","title":"SelfConsistentLogisticNoise.reconstruct_density","text":"reconstruct_density(fhat::Vector{ComplexF64}, xgrid::AbstractVector)\n\nReconstruct density f(x) from Fourier coefficients on the given grid.\n\n\n\n\n\nreconstruct_density(fhat::Vector{ComplexF64}; npts=1000)\n\nReconstruct density on a uniform grid with npts points.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.sweep_delta","page":"API Reference","title":"SelfConsistentLogisticNoise.sweep_delta","text":"sweep_delta(prob::SCProblem, Œ¥_range; warm_start=true, kwargs...)\n\nSweep over Œ¥ values, optionally using warm-start continuation.\n\nReturns a DataFrame with columns: Œ¥, m, c, residual, iterations, converged\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.sweep_delta_a","page":"API Reference","title":"SelfConsistentLogisticNoise.sweep_delta_a","text":"sweep_delta_a(; a_range, Œ¥_range, œÉ=0.02, N=256, kwargs...)\n\nSweep over both a and Œ¥ values.\n\nReturns a DataFrame with columns: a, Œ¥, m, c, residual, iterations, converged\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.multistart_solve","page":"API Reference","title":"SelfConsistentLogisticNoise.multistart_solve","text":"multistart_solve(prob::SCProblem; n_starts=5, kwargs...)\n\nRun solver from multiple initial conditions to detect multiple fixed points.\n\nReturns a vector of FixedPointResults, clustered by uniqueness.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.verify_fixed_point","page":"API Reference","title":"SelfConsistentLogisticNoise.verify_fixed_point","text":"verify_fixed_point(prob, fhat; œÑ=0.01, verbose=false)\n\nAttempt to rigorously verify that fhat is close to a true fixed point. Uses BallArithmetic for certified bounds on singular values.\n\nReturns a RigorousResult with verification status and all computed constants.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.RigorousResult","page":"API Reference","title":"SelfConsistentLogisticNoise.RigorousResult","text":"RigorousResult\n\nResult of rigorous verification.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.GaussianConstants","page":"API Reference","title":"SelfConsistentLogisticNoise.GaussianConstants","text":"GaussianConstants\n\nContainer for the Gaussian smoothing constants S{œÑ,œÉ}, S^(1){œÑ,œÉ}, S^(2)_{œÑ,œÉ}.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfConsistentLogisticNoise.compute_gaussian_constants","page":"API Reference","title":"SelfConsistentLogisticNoise.compute_gaussian_constants","text":"compute_gaussian_constants(œÉ, œÑ)\n\nCompute the Gaussian smoothing constants for given œÉ and œÑ. Uses rigorous interval arithmetic to ensure correct upper bounds.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.compute_jacobian_matrix","page":"API Reference","title":"SelfConsistentLogisticNoise.compute_jacobian_matrix","text":"compute_jacobian_matrix(prob::SCProblem, fhat::Vector{ComplexF64})\n\nCompute the Jacobian DT_N(f) = A(c) + b ‚äó a* at the candidate fÃÇ. Returns the full matrix representation.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.save_result","page":"API Reference","title":"SelfConsistentLogisticNoise.save_result","text":"save_result(filename::String, result::FixedPointResult)\n\nSave a FixedPointResult to a JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.load_result","page":"API Reference","title":"SelfConsistentLogisticNoise.load_result","text":"load_result(filename::String)\n\nLoad a FixedPointResult from a JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.modes","page":"API Reference","title":"SelfConsistentLogisticNoise.modes","text":"modes(N)\n\nReturn the range of Fourier modes: -N:N\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.idx","page":"API Reference","title":"SelfConsistentLogisticNoise.idx","text":"idx(k, N)\n\nConvert Fourier mode k ‚àà {-N,...,N} to 1-based array index. Mode k maps to index k + N + 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#SelfConsistentLogisticNoise.mode","page":"API Reference","title":"SelfConsistentLogisticNoise.mode","text":"mode(i, N)\n\nConvert 1-based array index i to Fourier mode k. Index i maps to mode i - (N+1).\n\n\n\n\n\n","category":"function"},{"location":"theory/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"theory/#The-Self-Consistent-Model","page":"Mathematical Background","title":"The Self-Consistent Model","text":"","category":"section"},{"location":"theory/#State-Space","page":"Mathematical Background","title":"State Space","text":"We work on the period-2 torus mathbbT = mathbbR(2mathbbZ), represented as -11) with wrap-around.","category":"section"},{"location":"theory/#The-Quadratic-Map","page":"Mathematical Background","title":"The Quadratic Map","text":"T_a(x) = a - (a+1)x^2\n\nWe interpret all phases in mathbbT (mod 2) when combining with noise and shift.","category":"section"},{"location":"theory/#Periodized-Gaussian-Noise","page":"Mathematical Background","title":"Periodized Gaussian Noise","text":"Let barrho_sigma be the periodized Gaussian kernel on mathbbT. Its Fourier coefficients are:\n\nwidehatbarrho_sigma(k) = exp(-tfracpi^22 sigma^2 k^2)","category":"section"},{"location":"theory/#Noisy-Transfer-Operator-with-Shift","page":"Mathematical Background","title":"Noisy Transfer Operator with Shift","text":"For each shift c in mathbbR:\n\n(P_c f)(x) = int_mathbbT barrho_sigma(x - T_a(y) - c) f(y)  dy","category":"section"},{"location":"theory/#Self-Consistency","page":"Mathematical Background","title":"Self-Consistency","text":"We define:\n\nObservable: m(f) = langle Phi f rangle = int_mathbbT Phi(x) f(x)  dx\nCoupling: c(f) = delta cdot G(m(f))\n\nThe self-consistent operator is:\n\nmathcalT(f) = P_c(f) f\n\nGoal: Find fixed points f^* with mathcalT(f^*) = f^*, int f^* = 1, f^* geq 0.","category":"section"},{"location":"theory/#Fourier-Discretization","page":"Mathematical Background","title":"Fourier Discretization","text":"","category":"section"},{"location":"theory/#Truncated-Fourier-Series","page":"Mathematical Background","title":"Truncated Fourier Series","text":"Densities are represented by truncated Fourier series:\n\nf(x) approx sum_k=-N^N hatf_k e^2pi i k x","category":"section"},{"location":"theory/#Operator-in-Fourier-Coordinates","page":"Mathematical Background","title":"Operator in Fourier Coordinates","text":"Define:\n\n(B_a hatf)_k = int_mathbbT e^-2pi i k T_a(y) f(y)  dy\n\nThen:\n\nwidehat(P_c f)_k = underbracee^-2pi^2 sigma^2 k^2_textGaussian cdot underbracee^-2pi i k c_textshift phase cdot (B_a hatf)_k","category":"section"},{"location":"theory/#Building-B_a-via-FFT","page":"Mathematical Background","title":"Building B_a via FFT","text":"Matrix entries:\n\n(B_a)_kell = int_mathbbT e^-2pi i k T_a(y) e^2pi i ell y  dy\n\nFFT trick: For each k, sample g_k(y) = e^-2pi i k T_a(y) on a fine grid and compute FFT.","category":"section"},{"location":"theory/#Rigorous-Verification-(Newton-Kantorovich)","page":"Mathematical Background","title":"Rigorous Verification (Newton-Kantorovich)","text":"The package implements rigorous computer-assisted proofs based on the Newton-Kantorovich theorem.","category":"section"},{"location":"theory/#Key-Constants","page":"Mathematical Background","title":"Key Constants","text":"For Gaussian smoothing with parameter sigma and analytic strip width tau:\n\nS_tausigma = sup_k in mathbbZ exp(2pitauk - 2pi^2sigma^2 k^2)\n\nS^(1)_0sigma leq frac1sigmasqrte quad S^(2)_0sigma leq frac2sigma^2 e","category":"section"},{"location":"theory/#Kantorovich-Condition","page":"Mathematical Background","title":"Kantorovich Condition","text":"Given a numerical candidate tildef with residual bound Delta, inverse Jacobian bound M, and Lipschitz constant gamma:\n\nIf h = M^2 gamma Delta leq frac12, then there exists a unique true fixed point f^* with:\n\nf^* - tildef_2 leq r = frac1 - sqrt1 - 2hMgamma","category":"section"},{"location":"generated/rigorous_delta_sweep/#Rigorous-Delta-Sweep-(Self-Consistent-Logistic-Noise)","page":"Delta Sweep","title":"Rigorous Delta Sweep (Self-Consistent Logistic Noise)","text":"This tutorial computes verified fixed points for a sweep of coupling strengths and plots only those with a rigorous L2 error bound below a target threshold.\n\nWe then compare selected deltas on a single plot.","category":"section"},{"location":"generated/rigorous_delta_sweep/#Mathematical-Setup","page":"Delta Sweep","title":"Mathematical Setup","text":"We study the self-consistent fixed point problem\n\nT(f) = P_c(f) f qquad c(f) = delta G(m(f))\n\nThe observable m(f) = langle phi f rangle is a scalar functional. In the default cosine case, phi(x) = cos(pi x) so m(f) is the first cosine Fourier coefficient. The coupling nonlinearity G is model-dependent; for the linear coupling used here, G(m) = m so c(f) = delta m(f). The underlying dynamics is the noisy quadratic map on the period-2 torus, x mapsto T_a(x) + c(f) with T_a(x) = a - (a+1)x^2, followed by Gaussian noise of width sigma. Note that this a is the parameter for the -1 1 quadratic map, not the logistic map a x(1-x) on 01.\n\nusing SelfConsistentLogisticNoise\nusing Plots\nusing Printf\nusing Serialization\n\ninclude(joinpath(@__DIR__, \"cert_log.jl\"))","category":"section"},{"location":"generated/rigorous_delta_sweep/#Configuration","page":"Delta Sweep","title":"Configuration","text":"a = 0.915         # Quadratic map parameter on [-1, 1]\nœÉ = 0.02          # Noise width\nN_candidates = [128, 192, 256, 384, 512, 768, 1024]\nŒ∑ = 0.0025\nœÉ_sm = 0.0075\nuse_taper = false\nM_override = 1048576\nœÑ_CAP = 0.1       # Analyticity strip for truncation bounds\ncache_dir = \".cache\"\nprecompute_B = true\nuse_snapshots = false\nwrite_markdown_summary = true\nwrite_latex_summary = true\n\nŒ¥_range = 0.0:0.01:0.5\nerror_threshold = 0.1\n\nnpts = 1000\noutput_dir = joinpath(\"docs\", \"literate\", \"rigorous_delta_sweep_png\")\nmkpath(output_dir)\nsnapshot_a = joinpath(output_dir, \"sweep_snapshot_A.bin\")\nsnapshot_b = joinpath(output_dir, \"sweep_snapshot_B.bin\")\nlog_path = joinpath(output_dir, \"certification_log.md\")\njld2_path = joinpath(output_dir, \"certification_output_delta_sweep.jld2\")\nlatex_path = joinpath(output_dir, \"certification_summary_delta_sweep.tex\")\n\nconfig = Dict(\n    :script => \"rigorous_delta_sweep\",\n    :a => a,\n    :œÉ => œÉ,\n    :N_candidates => N_candidates,\n    :Œ∑ => Œ∑,\n    :œÉ_sm => œÉ_sm,\n    :use_taper => use_taper,\n    :M_override => M_override,\n    :œÑ_CAP => œÑ_CAP,\n    :Œ¥_range => collect(Œ¥_range),\n    :error_threshold => error_threshold,\n    :npts => npts,\n    :log_path => log_path,\n    :jld2_path => jld2_path,\n    :latex_path => latex_path,\n)\n\nfunction load_snapshot(config, path_a, path_b)\n    paths = filter(isfile, (path_a, path_b))\n    if isempty(paths)\n        return Dict{Float64, NamedTuple}(), Dict{Float64, NamedTuple}()\n    end\n    mtimes = map(p -> stat(p).mtime, paths)\n    latest_path = paths[argmax(mtimes)]\n    state = try\n        deserialize(latest_path)\n    catch err\n        println(\"Snapshot load failed ($(err)); ignoring saved state.\")\n        return Dict{Float64, NamedTuple}(), Dict{Float64, NamedTuple}()\n    end\n    if get(state, :config, nothing) != config\n        println(\"Snapshot config mismatch; ignoring saved state.\")\n        return Dict{Float64, NamedTuple}(), Dict{Float64, NamedTuple}()\n    end\n    return state[:verified], state[:records]\nend\n\nfunction save_snapshot!(config, verified, records, path_a, path_b, toggle_ref)\n    state = Dict(\n        :config => config,\n        :verified => verified,\n        :records => records,\n        :timestamp => time(),\n    )\n    path = toggle_ref[] ? path_a : path_b\n    serialize(path, state)\n    toggle_ref[] = !toggle_ref[]\nend\n\nprintln(\"=\"^70)\nprintln(\"RIGOROUS DELTA SWEEP\")\nprintln(\"=\"^70)\nprintln(\"a = $a, œÉ = $œÉ, N candidates = $(N_candidates), œÑ = $œÑ_CAP\")\nprintln(\"Œ∑ = $Œ∑ (taper width)\")\nprintln(\"œÉ_sm = $œÉ_sm (smoothing width)\")\nprintln(\"taper = $use_taper, M = $M_override\")\nprintln(\"Œ¥ range = $(first(Œ¥_range)) to $(last(Œ¥_range)) (step = $(step(Œ¥_range)))\")\nprintln(\"L2 error threshold = $error_threshold\")","category":"section"},{"location":"generated/rigorous_delta_sweep/#Helper","page":"Delta Sweep","title":"Helper","text":"function compute_verified_density(prob::SCProblem, fhat::Vector{ComplexF64})\n    cap = verify_fixed_point_CAP(prob, fhat; œÑ=œÑ_CAP, verbose=false)\n    if cap.verified && cap.total_error <= error_threshold\n        xgrid, fvals = reconstruct_density(fhat; npts=npts)\n        return (xgrid=xgrid, fvals=fvals, cap=cap), cap\n    end\n    return nothing, cap\nend","category":"section"},{"location":"generated/rigorous_delta_sweep/#Sweep-and-Plot-(separate)","page":"Delta Sweep","title":"Sweep and Plot (separate)","text":"verified, records = use_snapshots ? load_snapshot(config, snapshot_a, snapshot_b) :\n    (Dict{Float64, NamedTuple}(), Dict{Float64, NamedTuple}())\nif !isempty(verified) || !isempty(records)\n    println(\"Loaded snapshot with $(length(records)) recorded points.\")\nend\nsnapshot_toggle = Ref(true)\nverified = copy(verified)\nrecords = copy(records)\n\nif precompute_B\n    println(\"\\nPrecomputing B matrices for all N (cached)...\")\n    pre_start = time()\n    map = QuadraticMap(a)\n    for N in N_candidates\n        disc = isnothing(M_override) ? FourierDisc(N) : FourierDisc(N, M_override)\n        build_B(map, disc; cache=true, cache_dir=cache_dir, Œ∑=Œ∑, œÉ_sm=œÉ_sm, taper=use_taper)\n    end\n    @printf(\"Precompute time: %.2f s\\n\", time() - pre_start)\nend\n\nprintln(\"\\nRunning sweep...\")\ntotal_start = time()\nfor Œ¥ in Œ¥_range\n    if use_snapshots && haskey(records, Œ¥)\n        @printf(\"\\nŒ¥ = %.2f (skipping; already recorded)\\n\", Œ¥)\n        continue\n    end\n    @printf(\"\\nŒ¥ = %.2f\\n\", Œ¥)\n    delta_start = time()\n    verified_entry = nothing\n    cap = nothing\n    used_N = nothing\n    for N in N_candidates\n        @printf(\"  trying N = %d\\n\", N)\n        prob = build_problem(\n            a=a, œÉ=œÉ, N=N, Œ¥=Œ¥, coupling_type=:linear,\n            Œ∑=Œ∑, œÉ_sm=œÉ_sm, taper=use_taper, M_override=M_override, cache=true\n        )\n        result = solve_hybrid(prob; Œ±=0.3, picard_tol=1e-6, newton_tol=1e-14, verbose=false)\n\n        if !result.converged\n            println(\"    solver did not converge; continuing\")\n            continue\n        end\n\n        verified_entry, cap = compute_verified_density(prob, result.fhat)\n        if verified_entry !== nothing\n            used_N = N\n            break\n        end\n        println(\"    not verified or error too large: total_error = $(cap.total_error)\")\n    end\n\n    if verified_entry === nothing\n        println(\"  no certified result for this Œ¥\")\n        records[Œ¥] = (\n            verified=false,\n            used_N=used_N,\n            total_error=cap === nothing ? nothing : cap.total_error,\n            cap=cap,\n            xgrid=nothing,\n            fvals=nothing,\n        )\n        save_snapshot!(config, verified, records, snapshot_a, snapshot_b, snapshot_toggle)\n        @printf(\"  elapsed: %.2f s\\n\", time() - delta_start)\n        continue\n    end\n\n    verified[Œ¥] = verified_entry\n    records[Œ¥] = (\n        verified=true,\n        used_N=used_N,\n        total_error=cap === nothing ? nothing : cap.total_error,\n        cap=cap,\n        xgrid=verified_entry.xgrid,\n        fvals=verified_entry.fvals,\n    )\n    save_snapshot!(config, verified, records, snapshot_a, snapshot_b, snapshot_toggle)\n    cap = verified_entry.cap\n    @printf(\"  verified at N = %d: total_error = %.6e\\n\", used_N, cap.total_error)\n    @printf(\"  elapsed: %.2f s\\n\", time() - delta_start)\n\n    p = plot(\n        verified_entry.xgrid,\n        verified_entry.fvals;\n        label=false,\n        lw=2,\n        title=@sprintf(\"Œ¥ = %.2f (L2 ‚â§ %.2e, N = %d)\", Œ¥, cap.total_error, used_N),\n        xlabel=\"x\",\n        ylabel=\"f(x)\",\n        size=(800, 400),\n    )\n    savefig(p, joinpath(output_dir, @sprintf(\"density_delta_%0.2f.png\", Œ¥)))\n    display(p)\nend\n@printf(\"\\nTotal sweep time: %.2f s\\n\", time() - total_start)","category":"section"},{"location":"generated/rigorous_delta_sweep/#Comparison-Plot-(selected-deltas)","page":"Delta Sweep","title":"Comparison Plot (selected deltas)","text":"selected = 0.0:0.1:0.5\np_compare = plot(\n    title=\"Verified stationary densities (selected Œ¥)\",\n    xlabel=\"x\",\n    ylabel=\"f(x)\",\n    size=(900, 500),\n)\n\nfor Œ¥ in selected\n    entry = get(verified, Œ¥, nothing)\n    if entry === nothing\n        @printf(\"  skipping Œ¥ = %.2f (not verified or not computed)\\n\", Œ¥)\n        continue\n    end\n    cap = entry.cap\n    plot!(\n        p_compare,\n        entry.xgrid,\n        entry.fvals;\n        label=@sprintf(\"Œ¥ = %.2f (‚â§ %.1e)\", Œ¥, cap.total_error),\n        lw=2,\n    )\nend\n\nsavefig(p_compare, joinpath(output_dir, \"density_comparison_selected.png\"))\ndisplay(p_compare)\n\nif write_markdown_summary\n    write_cert_log(\n        log_path;\n        title=\"Delta sweep certification log\",\n        key_label=\"Œ¥\",\n        key_format=Œ¥ -> @sprintf(\"%.2f\", Œ¥),\n        config=config,\n        records=records,\n    )\nend\nsave_state_jld2(jld2_path, config, verified, records)\n\nif write_latex_summary\n    write_latex_summary(\n        latex_path;\n        title=\"Rigorous delta sweep summary\",\n        key_label=\"\\\\\\$\\\\delta\\\\\\$\",\n        key_values=collect(0.0:0.05:0.5),\n        key_format=Œ¥ -> @sprintf(\"%.2f\", Œ¥),\n        records=records,\n        fig_path=joinpath(\"docs\", \"literate\", \"rigorous_delta_sweep_png\", \"density_comparison_selected.png\"),\n        fig_caption=\"Verified stationary densities for selected \\\\\\$\\\\delta\\\\\\$ values.\",\n        fig_label=\"delta_sweep\",\n    )\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#SelfConsistentLogisticNoise.jl","page":"Home","title":"SelfConsistentLogisticNoise.jl","text":"A Julia package for computing fixed points of self-consistent noisy transfer operators associated with the quadratic family on the period-2 torus.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This package implements numerical methods for finding fixed points of the self-consistent operator:\n\nmathcalT(f) = P_c(f) f\n\nwhere:\n\nT_a(x) = a - (a+1)x^2 is the quadratic map on -11\nP_c is the noisy transfer operator with periodized Gaussian noise and shift c\nc(f) = delta cdot G(m(f)) is a self-consistent shift depending on the density f\nm(f) = langle Phi f rangle is an observable (e.g., Phi(x) = cos(pi x))","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Fourier discretization with FFT-based operator construction\nDamped Picard iteration for fixed-point computation\nWarm-start continuation for parameter sweeps\nRigorous verification via Newton-Kantorovich theorem using BallArithmetic.jl","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using SelfConsistentLogisticNoise\n\n# Build problem: quadratic map with a=0.915, noise œÉ=0.02, coupling Œ¥=0.1\nprob = build_problem(a=0.915, œÉ=0.02, N=64, Œ¥=0.1)\n\n# Solve for fixed point\nresult = solve_fixed_point(prob; Œ±=0.3, tol=1e-10, verbose=true)\n\n# Reconstruct and plot density\nx, f = reconstruct_density(result.fhat; npts=500)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"This package is not registered. Install via:\n\nusing Pkg\nPkg.add(url=\"https://github.com/orkolorko/SelfConsistentLogisticNoise.jl\")","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"theory.md\", \"tutorials/fixed_point_tutorial.md\", \"api.md\"]\nDepth = 2","category":"section"},{"location":"generated/rigorous_a_sweep_sigma2_1e4/#Rigorous-a-Sweep-at-Fixed-Noise-Variance-(œÉ-1e-4)","page":"a Sweep","title":"Rigorous a-Sweep at Fixed Noise Variance (œÉ¬≤ = 1e-4)","text":"This tutorial sweeps the quadratic map parameter a in [0.9, 1.0] at fixed noise variance œÉ¬≤ = 1e-4 and coupling Œ¥ = 0. We only retain fixed points whose rigorous L2 error bound is below a target threshold. If certification fails, we retry with larger N.\n\nusing SelfConsistentLogisticNoise\nusing Plots\nusing Printf\n\ninclude(joinpath(@__DIR__, \"cert_log.jl\"))","category":"section"},{"location":"generated/rigorous_a_sweep_sigma2_1e4/#Configuration","page":"a Sweep","title":"Configuration","text":"œÉ2 = 1e-4\nœÉ = sqrt(œÉ2)\nŒ¥ = 0.0\nN_candidates = [128, 192, 256, 384, 512, 768, 1024]\nŒ∑ = 0.0025\nœÉ_sm = 0.0075\nuse_taper = false\nM_override = 1024\nœÑ_CAP = 0.1\nwrite_markdown_summary = true\nwrite_latex_summary = true\n\na_range = 0.9:0.001:1.0\nerror_threshold = 0.1\n\nnpts = 1000\noutput_dir = joinpath(\"docs\", \"literate\", \"rigorous_a_sweep_sigma2_1e4_png\")\nmkpath(output_dir)\nlog_path = joinpath(output_dir, \"certification_log.md\")\njld2_path = joinpath(output_dir, \"certification_output.jld2\")\nlatex_path = joinpath(output_dir, \"certification_summary_a_sweep.tex\")\n\nconfig = Dict(\n    :script => \"rigorous_a_sweep_sigma2_1e4\",\n    :œÉ2 => œÉ2,\n    :œÉ => œÉ,\n    :Œ¥ => Œ¥,\n    :N_candidates => N_candidates,\n    :Œ∑ => Œ∑,\n    :œÉ_sm => œÉ_sm,\n    :use_taper => use_taper,\n    :M_override => M_override,\n    :œÑ_CAP => œÑ_CAP,\n    :a_range => collect(a_range),\n    :error_threshold => error_threshold,\n    :npts => npts,\n    :log_path => log_path,\n    :jld2_path => jld2_path,\n)\n\nprintln(\"=\"^70)\nprintln(\"RIGOROUS a-SWEEP (œÉ¬≤ = 1e-4, Œ¥ = 0)\")\nprintln(\"=\"^70)\nprintln(\"œÉ¬≤ = $œÉ2, œÉ = $œÉ, Œ¥ = $Œ¥, œÑ = $œÑ_CAP\")\nprintln(\"Œ∑ = $Œ∑ (taper width)\")\nprintln(\"œÉ_sm = $œÉ_sm (smoothing width)\")\nprintln(\"taper = $use_taper, M = $M_override\")\nprintln(\"a range = $(first(a_range)) to $(last(a_range)) (step = $(step(a_range)))\")\nprintln(\"N candidates = $(N_candidates)\")\nprintln(\"L2 error threshold = $error_threshold\")","category":"section"},{"location":"generated/rigorous_a_sweep_sigma2_1e4/#Helper","page":"a Sweep","title":"Helper","text":"function compute_verified_density(prob::SCProblem, fhat::Vector{ComplexF64})\n    cap = verify_fixed_point_CAP(prob, fhat; œÑ=œÑ_CAP, verbose=false)\n    if cap.verified && cap.total_error <= error_threshold\n        xgrid, fvals = reconstruct_density(fhat; npts=npts)\n        return (xgrid=xgrid, fvals=fvals, cap=cap), cap\n    end\n    return nothing, cap\nend","category":"section"},{"location":"generated/rigorous_a_sweep_sigma2_1e4/#Sweep-and-Plot","page":"a Sweep","title":"Sweep and Plot","text":"println(\"\\nRunning sweep...\")\nverified = Dict{Float64, NamedTuple}()\nrecords = Dict{Float64, NamedTuple}()\nfor a in a_range\n    @printf(\"\\na = %.2f\\n\", a)\n    verified_entry = nothing\n    cap = nothing\n    used_N = nothing\n    for N in N_candidates\n        @printf(\"  trying N = %d\\n\", N)\n        prob = build_problem(\n            a=a, œÉ=œÉ, N=N, Œ¥=Œ¥, coupling_type=:linear,\n            Œ∑=Œ∑, œÉ_sm=œÉ_sm, taper=use_taper, M_override=M_override, cache=false\n        )\n        result = solve_hybrid(prob; Œ±=0.3, picard_tol=1e-6, newton_tol=1e-14, verbose=false)\n\n        if !result.converged\n            println(\"    solver did not converge; continuing\")\n            continue\n        end\n\n        verified_entry, cap = compute_verified_density(prob, result.fhat)\n        if verified_entry !== nothing\n            used_N = N\n            break\n        end\n        println(\"    not verified or error too large: total_error = $(cap.total_error)\")\n    end\n\n    if verified_entry === nothing\n        println(\"  no certified result for this a\")\n        records[a] = (\n            verified=false,\n            used_N=used_N,\n            total_error=cap === nothing ? nothing : cap.total_error,\n            cap=cap,\n            xgrid=nothing,\n            fvals=nothing,\n        )\n        continue\n    end\n\n    @printf(\"  verified at N = %d: total_error = %.6e\\n\", used_N, cap.total_error)\n    verified[a] = verified_entry\n    records[a] = (\n        verified=true,\n        used_N=used_N,\n        total_error=cap === nothing ? nothing : cap.total_error,\n        cap=cap,\n        xgrid=verified_entry.xgrid,\n        fvals=verified_entry.fvals,\n    )\n\n    p = plot(\n        verified_entry.xgrid,\n        verified_entry.fvals;\n        label=false,\n        lw=2,\n        title=@sprintf(\"a = %.2f (œÉ¬≤ = %.1e, N = %d)\", a, œÉ2, used_N),\n        xlabel=\"x\",\n        ylabel=\"f(x)\",\n        size=(800, 400),\n    )\n    savefig(p, joinpath(output_dir, @sprintf(\"density_a_%0.2f_N_%d.png\", a, used_N)))\n    display(p)\nend","category":"section"},{"location":"generated/rigorous_a_sweep_sigma2_1e4/#Comparison-Plot-(selected-a)","page":"a Sweep","title":"Comparison Plot (selected a)","text":"selected = collect(range(0.9, 0.99; length=10))\np_compare = plot(\n    title=\"Verified stationary densities (selected a)\",\n    xlabel=\"x\",\n    ylabel=\"f(x)\",\n    size=(900, 500),\n)\n\nfor a in selected\n    entry = get(verified, a, nothing)\n    if entry === nothing\n        @printf(\"  skipping a = %.2f (not verified or not computed)\\n\", a)\n        continue\n    end\n    cap = entry.cap\n    plot!(\n        p_compare,\n        entry.xgrid,\n        entry.fvals;\n        label=@sprintf(\"a = %.2f (‚â§ %.1e)\", a, cap.total_error),\n        lw=2,\n    )\nend\n\nsavefig(p_compare, joinpath(output_dir, \"density_comparison_selected.png\"))\ndisplay(p_compare)\n\nif write_markdown_summary\n    write_cert_log(\n        log_path;\n        title=\"a-sweep certification log (œÉ¬≤ = 1e-4)\",\n        key_label=\"a\",\n        key_format=a -> @sprintf(\"%.3f\", a),\n        config=config,\n        records=records,\n    )\nend\nsave_state_jld2(jld2_path, config, verified, records)\n\nif write_latex_summary\n    write_latex_summary(\n        latex_path;\n        title=\"a-sweep summary (\\\\$\\\\sigma^2=10^{-4}\\\\$)\",\n        key_label=\"\\\\\\$a\\\\\\$\",\n        key_values=collect(range(0.9, 0.99; length=10)),\n        key_format=a -> @sprintf(\"%.3f\", a),\n        records=records,\n        fig_path=joinpath(\"docs\", \"literate\", \"rigorous_a_sweep_sigma2_1e4_png\", \"density_comparison_selected.png\"),\n        fig_caption=\"Verified stationary densities for selected \\\\$a\\\\$ values.\",\n        fig_label=\"a_sweep\",\n    )\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/rigorous_noise_variance_sweep/#Rigorous-Noise-Variance-Sweep-(Œ¥-0)","page":"Noise Variance Sweep","title":"Rigorous Noise-Variance Sweep (Œ¥ = 0)","text":"This tutorial performs a sanity-check sweep over the noise variance (œÉ¬≤) while keeping the coupling fixed at Œ¥ = 0. We only retain fixed points whose rigorous L2 error bound is below a target threshold.\n\nusing SelfConsistentLogisticNoise\nusing Plots\nusing Printf\nusing Serialization\n\ninclude(joinpath(@__DIR__, \"cert_log.jl\"))","category":"section"},{"location":"generated/rigorous_noise_variance_sweep/#Configuration","page":"Noise Variance Sweep","title":"Configuration","text":"a = 0.915         # Quadratic map parameter on [-1, 1]\nŒ¥ = 0.0           # No coupling for this sweep\nN_candidates = [128, 192, 256, 384, 512, 768, 1024]\nŒ∑ = 0.0025\nœÉ_sm = 0.0075\nuse_taper = false\nM_override = 1048576\nœÑ_CAP = 0.1       # Analyticity strip for truncation bounds\ncache_dir = \".cache\"\nprecompute_B = true\nwrite_markdown_summary = true\nwrite_latex_summary = false\n\nSweep over variance: œÉ¬≤ in [0.0001, 0.0025] corresponds to œÉ in [0.01, 0.05]\n\nvar_range = 0.0001:0.0001:0.0025\nerror_threshold = 0.1\n\nnpts = 1000\noutput_dir = joinpath(\"docs\", \"literate\", \"rigorous_noise_variance_sweep_png\")\nmkpath(output_dir)\nsnapshot_a = joinpath(output_dir, \"sweep_snapshot_A.bin\")\nsnapshot_b = joinpath(output_dir, \"sweep_snapshot_B.bin\")\nlog_path = joinpath(output_dir, \"certification_log.md\")\njld2_path = joinpath(output_dir, \"certification_output.jld2\")\nlatex_path = joinpath(output_dir, \"certification_summary_noise_variance_sweep.tex\")\n\nconfig = Dict(\n    :script => \"rigorous_noise_variance_sweep\",\n    :a => a,\n    :Œ¥ => Œ¥,\n    :N_candidates => N_candidates,\n    :Œ∑ => Œ∑,\n    :œÉ_sm => œÉ_sm,\n    :use_taper => use_taper,\n    :M_override => M_override,\n    :œÑ_CAP => œÑ_CAP,\n    :var_range => collect(var_range),\n    :error_threshold => error_threshold,\n    :npts => npts,\n    :log_path => log_path,\n    :jld2_path => jld2_path,\n)\n\nfunction load_snapshot(config, path_a, path_b)\n    paths = filter(isfile, (path_a, path_b))\n    if isempty(paths)\n        return Dict{Float64, NamedTuple}(), Dict{Float64, NamedTuple}()\n    end\n    mtimes = map(p -> stat(p).mtime, paths)\n    latest_path = paths[argmax(mtimes)]\n    state = try\n        deserialize(latest_path)\n    catch err\n        println(\"Snapshot load failed ($(err)); ignoring saved state.\")\n        return Dict{Float64, NamedTuple}(), Dict{Float64, NamedTuple}()\n    end\n    if get(state, :config, nothing) != config\n        println(\"Snapshot config mismatch; ignoring saved state.\")\n        return Dict{Float64, NamedTuple}(), Dict{Float64, NamedTuple}()\n    end\n    return state[:verified], state[:records]\nend\n\nfunction save_snapshot!(config, verified, records, path_a, path_b, toggle_ref)\n    state = Dict(\n        :config => config,\n        :verified => verified,\n        :records => records,\n        :timestamp => time(),\n    )\n    path = toggle_ref[] ? path_a : path_b\n    serialize(path, state)\n    toggle_ref[] = !toggle_ref[]\nend\n\nprintln(\"=\"^70)\nprintln(\"RIGOROUS NOISE-VARIANCE SWEEP (Œ¥ = 0)\")\nprintln(\"=\"^70)\nprintln(\"a = $a, N candidates = $(N_candidates), œÑ = $œÑ_CAP, Œ¥ = $Œ¥\")\nprintln(\"Œ∑ = $Œ∑ (taper width)\")\nprintln(\"œÉ_sm = $œÉ_sm (smoothing width)\")\nprintln(\"taper = $use_taper, M = $M_override\")\nprintln(\"variance range = $(first(var_range)) to $(last(var_range)) (step = $(step(var_range)))\")\nprintln(\"L2 error threshold = $error_threshold\")","category":"section"},{"location":"generated/rigorous_noise_variance_sweep/#Helper","page":"Noise Variance Sweep","title":"Helper","text":"function compute_verified_density(prob::SCProblem, fhat::Vector{ComplexF64}, œÉ::Float64)\n    cap = verify_fixed_point_CAP(prob, fhat; œÑ=œÑ_CAP, verbose=false)\n    if cap.verified && cap.total_error <= error_threshold\n        xgrid, fvals = reconstruct_density(fhat; npts=npts)\n        return (xgrid=xgrid, fvals=fvals, cap=cap, œÉ=œÉ), cap\n    end\n    return nothing, cap\nend","category":"section"},{"location":"generated/rigorous_noise_variance_sweep/#Sweep-and-Plot","page":"Noise Variance Sweep","title":"Sweep and Plot","text":"verified, records = load_snapshot(config, snapshot_a, snapshot_b)\nif !isempty(verified) || !isempty(records)\n    println(\"Loaded snapshot with $(length(records)) recorded points.\")\nend\nsnapshot_toggle = Ref(true)\nverified = copy(verified)\nrecords = copy(records)\n\nif precompute_B\n    println(\"\\nPrecomputing B matrices for all N (cached)...\")\n    pre_start = time()\n    map = QuadraticMap(a)\n    for N in N_candidates\n        disc = isnothing(M_override) ? FourierDisc(N) : FourierDisc(N, M_override)\n        build_B(map, disc; cache=true, cache_dir=cache_dir, Œ∑=Œ∑, œÉ_sm=œÉ_sm, taper=use_taper)\n    end\n    @printf(\"Precompute time: %.2f s\\n\", time() - pre_start)\nend\n\nprintln(\"\\nRunning sweep...\")\nfor var in var_range\n    if haskey(records, var)\n        @printf(\"\\nœÉ¬≤ = %.4e (skipping; already recorded)\\n\", var)\n        continue\n    end\n    œÉ = sqrt(var)\n    @printf(\"\\nœÉ¬≤ = %.4e (œÉ = %.4e)\\n\", var, œÉ)\n\n    verified_entry = nothing\n    cap = nothing\n    used_N = nothing\n    for N in N_candidates\n        @printf(\"  trying N = %d\\n\", N)\n        prob = build_problem(\n            a=a, œÉ=œÉ, N=N, Œ¥=Œ¥, coupling_type=:linear,\n            Œ∑=Œ∑, œÉ_sm=œÉ_sm, taper=use_taper, M_override=M_override, cache=true\n        )\n        result = solve_hybrid(prob; Œ±=0.3, picard_tol=1e-6, newton_tol=1e-14, verbose=false)\n\n        if !result.converged\n            println(\"    solver did not converge; continuing\")\n            continue\n        end\n\n        verified_entry, cap = compute_verified_density(prob, result.fhat, œÉ)\n        if verified_entry !== nothing\n            used_N = N\n            break\n        end\n        println(\"    not verified or error too large: total_error = $(cap.total_error)\")\n    end\n\n    if verified_entry === nothing\n        println(\"  no certified result for this variance\")\n        records[var] = (\n            verified=false,\n            used_N=used_N,\n            total_error=cap === nothing ? nothing : cap.total_error,\n            cap=cap,\n            xgrid=nothing,\n            fvals=nothing,\n            œÉ=œÉ,\n        )\n        save_snapshot!(config, verified, records, snapshot_a, snapshot_b, snapshot_toggle)\n        continue\n    end\n\n    verified[var] = verified_entry\n    records[var] = (\n        verified=true,\n        used_N=used_N,\n        total_error=cap === nothing ? nothing : cap.total_error,\n        cap=cap,\n        xgrid=verified_entry.xgrid,\n        fvals=verified_entry.fvals,\n        œÉ=œÉ,\n    )\n    save_snapshot!(config, verified, records, snapshot_a, snapshot_b, snapshot_toggle)\n    @printf(\"  verified at N = %d: total_error = %.6e\\n\", used_N, cap.total_error)\n\n    p = plot(\n        verified_entry.xgrid,\n        verified_entry.fvals;\n        label=false,\n        lw=2,\n        title=@sprintf(\"œÉ¬≤ = %.4e (œÉ = %.3e, N = %d)\", var, œÉ, used_N),\n        xlabel=\"x\",\n        ylabel=\"f(x)\",\n        size=(800, 400),\n    )\n    savefig(p, joinpath(output_dir, @sprintf(\"density_sigma2_%0.4e_N_%d.png\", var, used_N)))\n    display(p)\nend\n\nif write_markdown_summary\n    write_cert_log(\n        log_path;\n        title=\"Noise-variance sweep certification log\",\n        key_label=\"œÉ¬≤\",\n        key_format=œÉ2 -> @sprintf(\"%.4e\", œÉ2),\n        config=config,\n        records=records,\n    )\nend\nsave_state_jld2(jld2_path, config, verified, records)\n\nif write_latex_summary\n    fig_path = joinpath(\"docs\", \"literate\", \"rigorous_noise_variance_sweep_png\", \"density_comparison_selected.png\")\n    if !isfile(fig_path)\n        println(\"Skipping LaTeX summary: missing comparison plot at $fig_path\")\n    else\n        write_latex_summary(\n            latex_path;\n            title=\"Noise-variance sweep summary\",\n            key_label=\"\\\\\\$\\\\sigma^2\\\\\\$\",\n            key_values=collect(var_range),\n            key_format=œÉ2 -> @sprintf(\"%.4e\", œÉ2),\n            records=records,\n            fig_path=fig_path,\n            fig_caption=\"Verified stationary densities for selected \\\\$\\\\sigma^2\\\\$ values.\",\n            fig_label=\"noise_variance_sweep\",\n        )\n    end\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
